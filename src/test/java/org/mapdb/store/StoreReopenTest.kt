package org.mapdb.store

import org.junit.*
import org.junit.Assert.*
import org.mapdb.*
import org.mapdb.TT.assertFailsWith
import org.mapdb.serializer.Serializers
import org.mapdb.volume.RandomAccessFileVol
import java.io.File
import java.util.*

abstract class StoreReopenTest(): StoreTest(){
    val file = TT.tempFile();

    abstract fun openStore(file: File): Store

    abstract val headerType:Long

    @After fun deleteFiles(){
        TT.tempDelete(file);
    }

    @Test open fun headerType(){
        val s = openStore(file)
        s.put(11L, Serializers.LONG)
        s.commit()
        s.close()
        val vol = RandomAccessFileVol.FACTORY.makeVolume(file.path, true)
        assertEquals(CC.FILE_HEADER,vol.getUnsignedByte(0L).toLong())
        assertEquals(headerType, vol.getUnsignedByte(1L).toLong())
    }



    @Test fun put_reopen_get() {
        var e = openStore(file)
        val l = 11231203099090L
        val recid = e.put(l, Serializers.LONG)
        e.commit()
        e.close()
        e = openStore(file)

        assertEquals(l, e.get(recid, Serializers.LONG))
        e.close()
    }


    @Test fun put_reopen_get_large() {
        var e = openStore(file)

        val b = TT.randomByteArray(1000000)
        val recid = e.put(b, Serializers.BYTE_ARRAY_NOSIZE)
        e.commit()
        e.close()
        e = openStore(file)

        assertTrue(Arrays.equals(b, e.get(recid, Serializers.BYTE_ARRAY_NOSIZE)))
        e.verify()
        e.close()
    }

    @Test fun large_record_update2() {
        var e = openStore(file)
        val b = TT.randomByteArray(1000000)
        val recid = e.put(b, Serializers.BYTE_ARRAY_NOSIZE)
        e.update(recid, b, Serializers.BYTE_ARRAY_NOSIZE)
        var b2 = e.get(recid, Serializers.BYTE_ARRAY_NOSIZE)
        assertTrue(Arrays.equals(b, b2))
        e.commit()
        e.close()
        e = openStore(file)

        b2 = e.get(recid, Serializers.BYTE_ARRAY_NOSIZE)
        assertTrue(Arrays.equals(b, b2))
        e.verify()
        e.close()
    }

    @Test
    fun large_record_larger() {
        if(TT.shortTest())
            return

        var e = openStore(file)
        val b = TT.randomByteArray(100000000)
        val recid = e.put(b, Serializers.BYTE_ARRAY_NOSIZE)
        var b2 = e.get(recid, Serializers.BYTE_ARRAY_NOSIZE)
        assertTrue(Arrays.equals(b, b2))
        e.verify()
        e.commit()
        e.close()
        e = openStore(file)

        b2 = e.get(recid, Serializers.BYTE_ARRAY_NOSIZE)
        assertTrue(Arrays.equals(b, b2))
        e.verify()
        e.close()
    }



    @Test fun test_store_reopen() {
        var e = openStore(file)
        val recid = e.put("aaa", Serializers.STRING)
        e.commit()
        e.commit()
        e.close()
        e = openStore(file)
        val aaa = e.get(recid, Serializers.STRING)
        assertEquals("aaa", aaa)
        e.verify()
        e.close()
    }


    @Test fun file_lock(){
        var e = openStore(file)
        e.put("aaa", Serializers.STRING)

        assertFailsWith(DBException.FileLocked::class.java, {
            openStore(file)
        })

        e.close()
    }

    @Test fun empty_rollback2(){
        val e = openStore(file)
        if(e is StoreTx)
            e.rollback()
        e.close()
    }

    @Test fun empty_commit2(){
        val e = openStore(file)
        e.commit()
        e.close()
    }



}